<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Index - Clarity Bootstrap Template</title>
  <meta name="description" content="">
  <meta name="keywords" content="">

  <!-- Favicons -->
  <link href="assets/img/favicon.png" rel="icon">
  <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">
  <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">

  <!-- Main CSS File -->
  <link href="assets/css/main.css" rel="stylesheet">

  <!-- =======================================================
  * Template Name: Clarity
  * Template URL: https://bootstrapmade.com/clarity-bootstrap-agency-template/
  * Updated: Sep 13 2025 with Bootstrap v5.3.8
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body class="index-page">

  <header id="header" class="header d-flex align-items-center sticky-top">
    <div class="header-container container-fluid container-xl position-relative d-flex align-items-center justify-content-between">

      <a href="#hero" class="logo d-flex align-items-center me-auto me-xl-0">
        <!-- Uncomment the line below if you also wish to use an image logo -->
        <!-- <img src="assets/img/logo.webp" alt=""> -->
        <h1 class="sitename">Microservices</h1>
      </a>

      <nav id="navmenu" class="navmenu">
        <ul>
          <li><a href="home.html" class="active">Home</a></li>
          <li><a href="#about">Da SOA a MA</a></li>
          <li><a href="#services">Perché</a></li>
          <li><a href="#portfolio">Descrizione</a></li>
          <li><a href="#team">Protocolli</a></li>
          <li><a href="#contact">Caratteristiche principali</a></li>
        </ul>
        <i class="mobile-nav-toggle d-xl-none bi bi-list"></i>
      </nav>


    </div>
  </header>

  <main class="main">

    <!-- Hero Section -->
    <section id="hero" class="hero section">

      <div class="container">
        <div class="row align-items-center">
          <div class="col-lg-6" data-aos="fade-right" data-aos-delay="100">
            <div class="hero-content">
              <h1>Transform Your Digital Presence</h1>
              <p>We create innovative digital solutions that drive growth and elevate your brand. From web development to digital marketing, we're your partners in digital transformation.</p>
            </div>
          </div>
          <div class="col-lg-6" data-aos="fade-left" data-aos-delay="200">
            <div class="hero-visual">
              <div class="hero-image">
                <img src="assets/img/misc/***" alt="Digital Agency Hero" class="img-fluid">
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="hero-bg-elements">
        <div class="bg-shape shape-1"></div>
        <div class="bg-shape shape-2"></div>
        <div class="bg-particles"></div>
      </div>

    </section><!-- /Hero Section -->

    <!-- About Section -->
    <section id="about" class="about section">
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>SOA e MA</title>
        </head>
        <body>
        <p>I software sono nati inizialmente per essere una singola entità, sviluppato con un solo linguaggio di programmazione e un solo eseguibile che gestisce tutto. Col tempo, questo sistema è diventato inefficiente perché
            presenta diversi svantaggi, che vanno dalla scalabilità, ai problemi di resilienza passando per gli aggiornamenti. Per questi motivi sono nate due architetture più complesse e che permettono la divisione del lavoro.</p>
        <h2>SOA service oriented architecture</h2>
        <p>L’architettura SOA è un sistema informatico in cui ci sono servizi che comunicano tra loro attraverso un sistema centralizzato chiamato Enterprise Service Bus.
            L’ESB è il cuore dell’architettura e si occupa di gestire tutte le comunicazioni tra i servizi, indirizzare le richieste al servizio corretto, trasformare i dati, controllare la sicurezza e registrare i log delle operazioni.

            Ogni servizio in una SOA è indipendente nelle sue funzioni ma collegato agli altri attraverso l’ESB. I servizi sono di solito completi e utilizzano database condivisi.
            Se il sistema deve crescere, si può effettuare una scalabilità orizzontale aggiungendo server o istanze per migliorare le prestazioni e la capacità di resistere ai guasti. In questo modo eventuali problemi non bloccano l’intero sistema.

            SOA è nata nei primi anni Duemila per aiutare le aziende a collegare tra loro sistemi diversi. È molto utile nei contesti dove ci sono molte applicazioni da integrare, ma è anche più complessa da gestire rispetto ad altri modelli più recenti.

            Un esempio tipico è un’azienda che possiede un servizio per la fatturazione, uno per la gestione degli ordini e uno per l’assistenza clienti. Tutti questi servizi comunicano attraverso l’ESB.</p>
        <br>
        <img src="assets/img/gruppo_microservizi/esb_soa.png" alt="immagine SOA" width="500">
        <h2>MA - Architettura a Microservizi</h2>

        <p>L’architettura a microservizi è un’evoluzione della SOA. In questo caso il sistema è diviso in tanti servizi più piccoli e indipendenti. Non c’è più un ESB centrale: ogni microservizio comunica con gli altri tramite API leggere, di solito REST o protocolli simili.

            Le richieste dei client passano attraverso un API Gateway che smista le chiamate al microservizio corretto. Ogni microservizio possiede il proprio database e può essere sviluppato, aggiornato e distribuito separatamente dagli altri. Questo rende il sistema più flessibile e più semplice da scalare.

            La scalabilità può essere fatta solo sul microservizio interessato, senza modificare gli altri. Inoltre, se un microservizio ha un problema, il resto del sistema continua a funzionare. Questo modello è adatto allo sviluppo su piattaforme cloud e a metodologie di lavoro agili, perché permette ai vari team di lavorare in parallelo su parti diverse dello stesso progetto.

            Un esempio può essere un sito di e-commerce con un microservizio per i pagamenti, uno per il carrello, uno per la gestione degli utenti e uno per le spedizioni. Se quello delle spedizioni si blocca, gli altri continuano a funzionare.</p>
        <img src="assets/img/gruppo_microservizi/api-gateway-1320x911.jpg" alt="immagine SOA" width="550">
        </body>
        </html>

    </section><!-- /About Section -->
      <section id="services" class="services section">
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <title>Perché si passa da SOA a Microservizi</title>
          </head>
          <body>
          <h1>Perché si passa da SOA a Microservizi</h1>
          <p>
              Il passaggio da SOA a microservizi non è casuale: è motivato da esigenze concrete delle aziende moderne. Con il tempo, la SOA ha mostrato limiti legati alla rigidità e alla centralizzazione, che rendevano difficile adattarsi rapidamente ai cambiamenti del mercato e alle nuove tecnologie.
          <p>Velocità di rilascio</p>
          In SOA, ogni modifica richiedeva approvazioni, coordinamento tra team e aggiornamenti di servizi complessi. Questo rallentava l’innovazione e la possibilità di reagire rapidamente. I microservizi risolvono questo problema perché ogni servizio può essere sviluppato, testato e distribuito in autonomia, senza dipendere dagli altri componenti. Questo permette cicli di rilascio più brevi e frequenti.
          <p>Scalabilità mirata</p>
          Con SOA, per gestire un aumento del carico spesso si dovevano scalare interi blocchi di servizi, con costi elevati e inefficienza. Nei microservizi, invece, è possibile scalare solo il servizio che ne ha bisogno: ad esempio, durante un picco di traffico in un e-commerce, si può scalare solo il microservizio che gestisce i pagamenti, senza aumentare le risorse per l’intero sistema.
          <p>Resilienza</p>
          In un’architettura SOA centralizzata, il malfunzionamento di un componente critico o dell’ESB poteva compromettere l’intero sistema. I microservizi isolano i guasti: se un servizio cade, gli altri continuano a funzionare, riducendo i downtime e migliorando la continuità operativa.
          Flessibilità tecnologica</p>
          SOA imponeva standard rigidi per linguaggi, database e protocolli, limitando la libertà dei team di sperimentare e scegliere le tecnologie migliori per ogni funzione. I microservizi consentono invece di adottare strumenti diversi a seconda delle necessità, accelerando l’innovazione e la capacità di adattamento.
          <p>Compatibilità con Cloud e DevOps</p>
          L’adozione dei microservizi è favorita dalla compatibilità con le pratiche moderne di cloud e DevOps. Tecnologie come container, orchestratori e pipeline CI/CD richiedono servizi indipendenti e modulari. I microservizi si integrano naturalmente in questo ecosistema, mentre la SOA, nata in un’epoca precedente, si adatta con maggiore difficoltà.
          <p>Conclusione</p>
          In sintesi, il passaggio da SOA a microservizi è guidato da cinque esigenze principali: velocità, scalabilità mirata, resilienza, flessibilità tecnologica e compatibilità con il cloud/DevOps. Non si tratta di un semplice cambio di moda, ma di una scelta strategica per rendere i sistemi più agili, efficienti e affidabili.</p>
          </body>
          </html>


          <section id="portfolio" class="portfolio section">
              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <title>Descrizione</title>
              </head>
              <body>
              <h1>Descrizione microservices</h1>
              <p>
                  Un’architettura a microservizi è un modello in cui un’applicazione è scomposta in molti servizi più o meno indipendenti, ciascuno responsabile di una certa funzionalità o ambito di business.
              </p>
              <p>Ogni microservizio:</p>

              <p>È autonomo: ha un proprio ciclo di vita (sviluppo, test, deploy) e può essere aggiornato o modificato senza influenzare gli altri.
                  È loosely coupled: i servizi dipendono il meno possibile l’uno dall’altro, in modo che eventuali modifiche o problemi in uno non si ripercuotano sugli altri.
                  Ha il proprio stack tecnologico: un insieme di tecnologie, linguaggi e strumenti scelti per le proprie esigenze, oltre al proprio database. Questo serve ad evitare che i servizi si “incrocino” a livello di dati e a garantire maggiore indipendenza.
                  Comunica tramite protocolli leggeri: i microservizi parlano tra loro usando metodi semplici, veloci e poco costosi (in termini di risorse).
              </p>

              <p>Un grande vantaggio dei microservizi è la scalabilità: ogni servizio può essere potenziato singolarmente se riceve più richieste, senza dover modificare l’intera applicazione. Inoltre, i microservizi possono essere distribuiti e aggiornati in modo indipendente, permettendo di aggiungere nuove funzioni o correggere errori più rapidamente.
              </p>
              <p>Anche la manutenzione risulta più semplice, perché ogni servizio è più piccolo, facile da capire e da testare. Spesso, ogni microservizio viene gestito da un piccolo team dedicato, che può lavorare in modo indipendente dagli altri.
              </p>
              <p>Tuttavia, questa architettura porta anche alcune difficoltà, come una maggiore complessità nella comunicazione tra i servizi, la necessità di monitoraggio costante e una gestione più accurata dell’infrastruttura.
              </p>
              </body>
              </html>
    </section>
          <section id="team" class="team section">
              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <title>Protocolli</title>
              </head>
              <body>
              <h1>Protocolli</h1>
              <p>I microservizi utilizzano diversi protocolli di comunicazione a seconda che la comunicazione sia sincrona o asincrona e se sia interna o esterna. I protocolli più comuni includono HTTP/REST per la comunicazione sincrona, AMQP per la messaggistica asincrona e gRPC per le chiamate di procedura remota ad alte prestazioni. La scelta del protocollo dipende dal caso d'uso specifico, come la comunicazione tra servizi all'interno di un cluster o con sistemi esterni.
                  Protocolli sincroni</p>
              <p>HTTP/REST: Molto comune per la comunicazione sincrona (richiesta/risposta), specialmente quando i servizi devono essere esposti pubblicamente.
              </p><p>gRPC: Un framework per le chiamate di procedura remota ad alte prestazioni, spesso usato per la comunicazione interna tra microservizi.
              </p><p>TCP: Può essere utilizzato per la comunicazione tra servizi, specialmente in formati binari, per una maggiore efficienza.
                  Protocolli asincroni
              </p><p>AMQP: Un protocollo di messaggistica standard utilizzato per la comunicazione asincrona e affidabile tra i microservizi, spesso tramite broker di messaggi.
                  Messaggistica asincrona generica: Si basa sull'invio e la ricezione di messaggi, che possono essere in formati diversi come JSON o XML.
                  Altri protocolli
              </p><p>SOAP: Un protocollo standardizzato, spesso associato ai servizi web tradizionali, che può essere utilizzato anche per la comunicazione con altri sistemi esterni.
              </p><p>XML-RPC: Un altro protocollo per la comunicazione tra i servizi.
              </p><p>Protocolli di transazione distribuiti: Per gestire transazioni complesse che coinvolgono più microservizi, vengono utilizzati protocolli come XA, Long-Running Actions (LRA) e try-confirm/cancel (TCC).</p>
              </body>
              </html>

          </section>
          <section id="contact" class="contact section">
              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <title>Caratteristiche principali</title>
              </head>
              <body>
              <h1>Caratteristiche principali</h1>
              <p>1. Servizio unico / Single Responsibility</p>
              <p>Ogni microservizio è progettato attorno a una singola funzionalità di business ben definita, non a un insieme eterogeneo di compiti. Autonomia e deploy indipendente</p>
              <br>
              <p>2. Ogni servizio può essere sviluppato, testato, distribuito e scalato in modo indipendente dagli altri. Ciò aumenta l’agilità e riduce i rischi sul rilascio.</p>
              <br>
              <p>3. Accoppiamento debole (Loose coupling)</p>
              <p>I microservizi sono “leggeri” nelle dipendenze reciproche: comunicano tramite interfacce (API) ben definite, riducendo l’impatto delle modifiche.</p>
              <br>
              <p>4. Dati decentralizzati / Proprietà dei dati per servizio</p>
              <p>Ogni microservizio gestisce il proprio storage/database, evitando database applicativi condivisi che causano dipendenze forti e complessità.</p>
              <br>
              <p>5. Scalabilità e resilienza</p>
              <p>È possibile scalare solo il microservizio che ne ha bisogno (in orizzontale, ad esempio), e un guasto in un servizio non necessariamente compromette l’intera applicazione.</p>
              <br>
              <p>6. Organizzazione attorno al dominio di business</p>
              <p>L’architettura viene spesso strutturata ragionando in termini di domini (domain-driven design) piuttosto che solo layer tecnici.</p>
              <br>
              <p>7. Tecnologie eterogenee e indipendenza tecnologica</p>
              <p>Ogni servizio può usare il linguaggio, il framework, il database che più si adattano al suo scopo (“polyglot persistence”, “polyglot programming”).</p>
              <br>
              <p>8. Osservabilità, Fail-fast, tolleranza ai guasti</p>
              <p>In un sistema distribuito occorre prevedere il fallimento di un servizio. Vengono quindi adottati pattern come circuit breaker, retry, fallback; monitoraggio, logging e tracing diventano fondamentali.</p>
              <br>
              <p>9. Automazione, CI/CD, contenitori / cloud-native</p>
              <p>I microservizi spesso nascono o sono implementati in ambienti che supportano containerizzazione, orchestrazione (es. Kubernetes), e pipeline di integrazione e distribuzione continue.</p>
              <br>
              <hr>
              <p>Quando conviene e quali i trade-off</p>
              <p>Vantaggi: maggiore agilità, capacità di cambiamento locale (senza toccare tutto), migliore scalabilità, autonomia dei team, possibilità di scegliere tecnologie specifiche per ciascuna parte del sistema.</p>
              <br>
              <p>Sfide: complessità dei sistemi distribuiti (network, latenza, consistenza dei dati), gestione delle versioni delle API, operazioni più complesse (monitoraggio, distribuzione, test), individuazione della giusta granularità dei servizi.</p>
              </body>
              </html>
          </section>
          <br><br><br><br>
          Sitografia:
          <br><a href="https://universeit.blog/architettura-a-microservizi/">https://universeit.blog/architettura-a-microservizi/</a>
          <br><a href="https://aws.amazon.com/it/compare/the-difference-between-soa-microservices/">https://aws.amazon.com/it/compare/the-difference-between-soa-microservices/</a>
          <br><a href="https://developer.ibm.com/articles/why-microservices/">https://developer.ibm.com/articles/why-microservices/</a>
          <br><a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>
          <br><a href="https://www.atlassian.com/microservices">https://www.atlassian.com/microservices</a>
          <br><a href="https://aws.amazon.com/microservices">https://aws.amazon.com/microservices</a>
          <br><a href="https://aws.amazon.com/microservices">https://aws.amazon.com/microservices</a>
          <br><a href="https://microservices.io/post/architecture/2023/03/28/microservice-architecture-essentials-loose-coupling.html">https://microservices.io/post/architecture/2023/03/28/microservice-architecture-essentials-loose-coupling.html</a>
          <br><a href="https://www.ibm.com/think/topics/microservices">https://www.ibm.com/think/topics/microservices</a>
          <script src="assets/js/main.js"></script>
</body>

</html>